# 1. Professional:

### 1.1 Componentes e injeção de dependência

- [x] Preparação de ambiente
- [x] Sistema e componentes
- [x] Inversão de controle e injeção de dependência
- [x] Trocando a dependência sem abrir o componente pai
- [x] Frameworks
- [x] Criação de projeto Spring Boot
- [x] Implementação de componentes no Spring Boot
- [x] DESAFIO: Componentes e Injeção de Dependência

### 1.2 Modelo de Domínio e ORM

- [x] Revisão de Álgebra Relacional e SQL
- [x] Super revisão de OO e SQL com Java e JDBC
- [x] Nivelamento ORM - JPA e Hibernate
- [x] Documento de requisitos do sistema DSCommerce
- [x] Criando o projeto Spring Boot
- [x] Entidade User, banco H2
- [x] Order, Enum, relacionamento muitos-para-um
- [x] Payment, relacionamento um-para-um
- [x] Muitos-para-muitos, column unique e text
- [x] Muitos-para-muitos com classe de associação PARTE 1
- [x] Muitos-para-muitos com classe de associação PARTE 2
- [x] Seeding da base de dados
- [x] DESAFIO: Modelo de Domínio e ORM

### 1.3 API REST, camadas, CRUD, exceções, validações

- [x] O que é uma API REST
- [x] Recursos, URL, parâmetros de consulta e de rota
- [x] Padrões de URL, verbos HTTP, códigos de resposta
- [x] Padrão camadas
- [x] Acessando API
- [ ] Repository
- [ ] Criando DTO e estruturando camadas
- [ ] Dica da biblioteca ModelMapper para DTO
- [ ] CRUD
- [ ] Busca paginada
- [ ] Inserção com POST
- [ ] Customizando resposta com ResponseEntity
- [ ] Atualização com PUT
- [ ] Deleção com DELETE
- [ ] Criando exceções de serviço customizadas
- [ ] Tratando exceção com resposta customizada
- [ ] Validação com Bean Validation
- [ ] Customizando a resposta da validação
- [ ] DESAFIO: CRUD de clientes

### 1.4 JPA, consultas SQL e JPQL

- [ ] Sessão JPA e estados de entidades
- [ ] Salvando entidade associada para um
- [ ] Salvando entidades associadas para muitos
- [ ] Evitando degradação de performance
- [ ] Carregamento EAGER e LAZY
- [ ] Analisando o carregamento lazy de entidades
- [ ] Alterando o atributo fetch dos relacionamentos
- [ ] Otimizando consultas com a cláusula JOIN FETCH
- [ ] Entendendo Transactional e open-in-view
- [ ] Consultas com Query Methods
- [ ] Introdução sobre JPQL
- [ ] Polêmica vale a pena especializar na JPQL
- [ ] Preparando para os estudos de caso de consultas
- [ ] Estudo de caso URI 2602: consulta simples
- [ ] Estudo de caso URI 2611: INNER JOIN
- [ ] Estudo de caso URI 2621: BETWEEN LIKE
- [ ] Estudo de caso URI 2609: GROUP BY
- [ ] Estudo de caso URI 2737: UNION ALL, LEFT JOIN
- [ ] Estudo de caso URI 2990: NOT IN
- [ ] Estudo de caso: DSCommerce consulta de produtos por nome
- [ ] DESAFIO: Consulta vendas

### 1.5 Login e controle de acesso

- [ ] Ideia geral do login e controle de acesso
- [ ] Visão geral do OAuth2
- [ ] Login, credenciais e JWT
- [ ] Preparando projeto com bibliotecas
- [ ] Modelo de dados User e Role
- [ ] UserDetails, GrantedAuthority, UserDetailsService
- [ ] Armazenamento da senha codificada com BCrypt
- [ ] Checklist do OAuth2 com JWT no Spring Boot
- [ ] Requisição de login no Postman
- [ ] Deixando o Postman top
- [ ] Acessando recursos protegidos
- [ ] Controle de acesso aos endpoints
- [ ] Variáveis de ambiente no projeto
- [ ] Configuração de CORS
- [ ] Obtendo usuário logado
- [ ] Controle de acesso programático self ou admin
- [ ] Endpoint para buscar categorias
- [ ] DESAFIO: Projeto Spring Boot estruturado

### 1.6 Homologação e implantação com CI/CD

- [ ] Setup do ambiente local Postgresql e pgAdmin com Docker e Docker Compose
- [ ] Perfis de projeto: test, dev, prod
- [ ] Profile dev para homologação Postgresql
- [ ] Profile prod para projeto em produção na nuvem
- [ ] Geração de script de criação e seed da base de dados
- [ ] Procedimento deploy com CI/CD no Heroku
- [ ] Procedimento deploy com CI/CD no Railway


